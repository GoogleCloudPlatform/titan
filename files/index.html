<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta content="chrome=1" http-equiv="X-UA-Compatible">
    <meta content="Titan for App Engine : App Engine, extended." name="description">
    <link href="/titan/css/stylesheet.css" media="screen" rel="stylesheet">
    <title>
      Titan Files - Titan for App Engine
    </title>
    <style>
div.c1 {padding: 10px; border: 1px solid #f6f9ff; background: #f6f9ff;}
    </style>
  </head>
  <body>
    <div class="outer" id="header_wrap">
      <header class="inner">
        <a href="https://github.com/GoogleCloudPlatform/titan" id="forkme_banner">View on
        GitHub</a>
        <h1 id="project_title">
          Titan for App Engine
        </h1>
        <h2 id="project_tagline">
          App Engine, extended.
        </h2>
        <section id="downloads">
          <a class="zip_download_link" href=
          "https://github.com/GoogleCloudPlatform/titan/zipball/master">Download this project as a
          .zip file</a> <a class="tar_download_link" href=
          "https://github.com/GoogleCloudPlatform/titan/tarball/master">Download this project as a
          tar.gz file</a>
        </section>
      </header>
    </div>
    <div class="outer" id="main_content_wrap">
      <section class="inner" id="main_content">
        <div id="breadcrumbs">
          <a href="/titan/">Titan</a> &gt; Titan Files
        </div>
        <hr>
        <div class="c1">
          <strong>We're moving to <a href=
          "https://github.com/GoogleCloudPlatform/titan">GitHub</a>! Pardon our dust as we move
          things over and update docs.</strong> 2013-05-02
        </div>
        <h1>
          Titan Files
        </h1>
        <h2>
          Introduction
        </h2>
        <p>
          Titan Files is a filesystem abstraction for App Engine apps, providing a file-like API
          for storing and retrieving data.
        </p>
        <pre>
<code>from titan import files

titan_file = files.File('/some/file.html')
titan_file.write(content='Hello world!')

titan_file.content  # Returns 'Hello world!'
titan_file.delete()
</code>
</pre>
        <h3>
          Features
        </h3>
        <ul>
          <li>
            <strong>Simple file-like API</strong>.
          </li>
          <li>
            <strong>Command-line utilities</strong> for uploading/downloading files from your app.
          </li>
          <li>
            <strong>Abitrary file metadata</strong> and metadata queries are supported.
          </li>
          <li>
            <strong>No file size limit</strong> (large files are transparently written to
            blobstore).
          </li>
          <li>
            <strong>Aggressive caching</strong> internally (included sharded caching of files
            &lt;32 MB).
          </li>
          <li>
            <strong>Unit tests</strong> are robust.
          </li>
          <li>
            <strong>Modular</strong> and reuable—does not depend on any other Titan modules to
            work.
          </li>
        </ul>
        <p>
          Here's a 5-minute, fast-paced lightning talk from PyCon 2013 that covers Titan Tasks and
          then Titan Files: <iframe allowfullscreen="" frameborder="0" height="360" src=
          "//www.youtube.com/embed/Ft6-r_vksDI?rel=0&amp;start=2268" width="480"></iframe>
        </p>
        <h2>
          Installation
        </h2>
        <p>
          See the <a href="/titan/install.html">Titan installation guide</a>.
        </p>
        <h2>
          Philosophy
        </h2>
        <ul>
          <li>Files just work.
          </li>
          <li>Most data is schemaless.
          </li>
          <li>Data portability counts, big time.
          </li>
          <li>It's still a database.
          </li>
        </ul>
        <p>
          <strong>Files just work</strong>. Everyone understands files. They're easy to reason
          about and use. They have metadata you always need, like creation time and who last
          modified the file. They're standard, isolatable, and flexible.
        </p>
        <p>
          <strong>Most data is schemaless.</strong> You just want to <em>store some data</em>, not
          care about defining a perfect mold for it beforehand. You care about lightweight
          normalization and serialization formats, not proprietary database types and strict
          models.
        </p>
        <p>
          <strong>Data portability counts, big time.</strong> 'Nuff said.
        </p>
        <p>
          <strong>It's still a database.</strong> Titan Files still uses the App Engine Datastore
          underneath, so you still get all the powerful NoSQL features that you'd expect: indexes
          on arbitrary metadata, fixed-cost queries (now with file-like semantics), and of course
          automatic scalability, durability, and replication.
        </p>
        <h2>
          Quickstart
        </h2>
        <h3>
          Writing files
        </h3>
        <p>
          Let's make a very simple app; just a POST API where you accept a <code>key</code> and a
          <code>message</code> to store.
        </p>
        <p>
          We'll use the webapp2 framework for these docs, but you can use whatever framework you'd
          like.
        </p>
        <pre>
<code>import webapp2
from titan import files

class MessageHandler(webapp2.RequestHandler):
  def post(self):
    key = self.request.get('key')
    message = self.request.get('message')
    if not key or '/' in key:
      self.abort(400)
    files.File('/messages/{}'.format(key)).write(message)
</code>
</pre>
        <p>
          Easy, right? Storing data is as simple as:
          <code>files.File('/some/path').write('hello!')</code>
        </p>
        <h3>
          Reading files
        </h3>
        <p>
          Now let's add a way to retrieve messages by <code>key</code>:
        </p>
        <pre>
<code>  def get(self):
    key = self.request.get('key')
    titan_file = files.File('/messages/{}'.format(key))
    if not titan_file.exists:
      self.abort(404)
    self.response.out.write(titan_file.content)
</code>
</pre>
        <p>
          Done! You can now store and read messages, and there's not a model in sight.
        </p>
        <h3>
          Listing files
        </h3>
        <p>
          Let's go a bit further and add a handler where you can list all the messages by
          <code>key</code>:
        </p>
        <pre>
<code>class MessageListHandler(webapp2.RequestHandler):

  def get(self):
    titan_files = files.Files.list('/messages/', recursive=False)
    self.response.out.write('KEYS:&lt;br&gt;')
    self.response.out.write('&lt;br&gt;'.join(titan_files.keys()))
</code>
</pre>
        <p>
          We simply use the the <code>files.Files.list</code> factory method to list files in the
          <code>/messages/</code> directory. The <code>list</code> factory methods returns a
          <code>files.Files</code> object, a dictionary-like object that maps file paths to
          lazy-loading <code>File</code> objects.
        </p>
        <p>
          But we have a problem—this handler will output the actual filenames, not the keys:
        </p>
        <pre>
<code>KEYS:
/messages/some-key
/messages/my-message-for-you
</code>
</pre>
        <p>
          Obviously we don't want to show this to our users, so we could solve this in a few
          different ways:
        </p>
        <ul>
          <li>We could parse the filenames, like:<br>
            <code>[k[len('/messages/'):] for k in titan_files]</code>.
          </li>
          <li>We could store JSON in the file instead, like:<br>
            <code>titan_file.write(json.dumps({'key': key, 'message': message})</code>
          </li>
          <li>Or, we could store a <code>message_key</code> meta property on the file. We'll
          explore metadata more in the next section.
          </li>
        </ul>
        <h3>
          Metadata
        </h3>
        <p>
          Underneath it all, Titan Files uses an <a href=
          "https://developers.google.com/appengine/docs/python/ndb/entities#expando">ndb.Expando</a>
          model and normal files are just <a href=
          "https://developers.google.com/appengine/docs/python/ndb/entities">datastore
          entities</a>. This means that we can harness all the power of the App Engine Datastore
          for doing more complicated things, like indexing and querying on custom file properties.
        </p>
        <p>
          For example, say we wanted the ability to add "tags" to messages, so we can filter
          messages by tag. Let's modify the message handler to write metadata:
        </p>
        <pre>
<code>class MessageHandler(webapp2.RequestHandler):
  def post(self):
    key = self.request.get('key')
    message = self.request.get('message')
    tags = self.request.get_all('tags')
    metadata = {'tags': tags, 'message_key': key}
    files.File('/messages/{}'.format(key)).write(message, meta=metadata)
</code>
</pre>
        <p>
          The <code>write()</code> method simply accepts a <code>meta</code> argument, which is a
          dictionary of the metadata you want to store. Metadata is accessed through the
          <code>meta</code> property of files:
        </p>
        <pre>
<code>&gt;&gt;&gt; files.File('/messages/some-key').meta.message_key
'some-key'
&gt;&gt;&gt; files.File('/messages/some-key').meta.tags
['some-tag', 'blue', 'archived-message']
</code>
</pre>
        <p>
          Meta properties have the default indexes applied and can be used in custom indexes as
          well. Since they're normal entities properties, we can also filter queries on meta
          properties.
        </p>
        <h4>
          Filtering with metadata queries
        </h4>
        <p>
          Let's modify the message list handler to filter based on tag:
        </p>
        <pre>
<code>class MessageListHandler(webapp2.RequestHandler):

  def get(self):
    tag = self.request.get('tag')

    filters = []
    if tag:
      filters = [files.FileProperty('tag') == tag]

    titan_files = files.Files.list('/messages/', filters=filters)

    # Use .load() here to fetch all of the files in batch, to avoid
    # sequential RPCs when accessing file properties below.
    titan_files.load()

    # Show the 'message_key' meta property to users instead of the filename.
    message_keys = [f.meta.message_key for f in titan_files.itervalues()]
    self.response.out.write('KEYS:&lt;br&gt;')
    self.response.out.write('&lt;br&gt;'.join(message_keys))
</code>
</pre>
        <p>
          Now the output will be just the original message keys, and will be filtered to only the
          files with the given tag:
        </p>
        <pre>
<code>KEYS:
some-key
my-message-for-you
</code>
</pre>
        <p>
          Notice that filters look the same as <a href=
          "https://developers.google.com/appengine/docs/python/ndb/queries#filter_by_prop">NDB
          property filters</a> —because they are. You can use all of the standard filter operators,
          and it's subject to the same constraints. You can even do recursive queries with filters
          like <code>files.Files.list('/some-dir/', recursive=True, filters=filters)</code> to find
          files across the <em>entire</em> filesystem nearly instantly. This will have the same
          fixed-cost performance as other queries since it's just a datastore query underneath.
        </p>
        <h2>
          File object reference.
        </h2>
        <p>
          The base <code>files.File</code> object has the following methods and properties:
        </p>
        <pre>
<code>from titan import files

titan_file = files.File('/path/to/file.html')

titan_file.write('Some content')
titan_file.delete()
titan_file.copy_to(destination_file=files.File('/other/file.html'))
titan_file.move_to(destination_file=files.File('/other/file.html'))
titan_file.serialize()
titan_file.validate_path('/some/path')

titan_file.name         # "file.html"
titan_file.name_clean   # "file"
titan_file.extension    # ".html"
titan_file.path         # "/path/to/file.html"
titan_file.paths        # ["/", "/path", "/path/to"]
titan_file.mime_type    # "text/html"
titan_file.created      # datetime.datetime object.
titan_file.modified     # datetime.datetime object.
titan_file.content      # 'Some content'
titan_file.blob         # blobstore.BlobInfo object, if stored in blobstore.
titan_file.exists       # Boolean.
titan_file.created_by   # titan.users.TitanUser object.
titan_file.modified_by  # titan.users.TitanUser object.
titan_file.size         # Integer number of bytes.
titan_file.md5_hash     # Pre-computed md5_hash of the file contents.
titan_file.meta         # Metadata object.
</code>
</pre>
        <p>
          <code>File</code> objects are lazily evaluated by default—this means that no RPCs are
          made until a method or property on the object is accessed.
        </p>
        <h2>
          Client interfaces to the HTTP API
        </h2>
        <p>
          Titan Files provides many client interfaces for remotely managing files. This is
          especially useful for uploading local files to an App Engine app.
        </p>
        <h3>
          Setup
        </h3>
        <p>
          For an app to support any of these clients, you must first expose the Titan handlers in
          your application.
        </p>
        <p>
          In your app.yaml:
        </p>
        <pre>
<code>includes:
- titan/files/handlers.yaml
</code>
</pre>
        <p>
          And install these two libraries:
        </p>
        <pre>
<code>$ pip install python-gflags poster
</code>
</pre>
        <p>
          The python-gflags library is used for the command-line flag handling and poster for
          handling large uploads via multipart POSTs.
        </p>
        <p>
          Also, make sure that your PYTHONPATH is set up correctly. If the App Engine SDK is in
          your home dir, you can run:
        </p>
        <pre>
<code>$ export PYTHONPATH=~/google_appengine/:$PYTHONPATH
$ export PYTHONPATH=~/google_appengine/lib/fancy_urllib/:$PYTHONPATH
# Change this to be the correct path for your project (where the "titan" folder is):
$ export PYTHONPATH=~/src/your/project/:$PYTHONPATH
</code>
</pre>
        <h3>
          Command-line client
        </h3>
        <p>
          Titan provides a command-line client for uploading local files to an AppEngine app and
          for downloading remote Titan files to your local filesystem.
        </p>
        <p>
          NOTE: Pass the <code>--insecure</code> flag with these commands if using the
          dev_appserver.
        </p>
        <p>
          Upload usage:
        </p>
        <pre>
<code>$ ./titanfiles.py upload --host=&lt;hostname&gt; [--root_dir=.] [--target_path=/] &lt;filenames&gt;
</code>
</pre>
        <p>
          Upload example:
        </p>
        <pre>
<code>$ cd titan/files/utils

# Upload local files to remote directory "/foo/bar/":
$ ./titanfiles.py upload --host=example.appspot.com --root_dir=~/src/ ~/src/foo/bar/a.txt ~/src/foo/bar/b.txt

# Upload files to "/foo/bar/" recursively:
$ ./titanfiles.py upload --host=example.appspot.com --root_dir=~/src/ `find ~/src/foo/bar/ -type f`
</code>
</pre>
        <p>
          Download usage:
        </p>
        <pre>
<code>$ ./titanfiles.py download --host=&lt;hostname&gt; --file_path=&lt;remote file path&gt; [target local directory]
$ ./titanfiles.py download --host=&lt;hostname&gt; --dir_path=&lt;remote directory path&gt; [target local directory]
</code>
</pre>
        <p>
          Download example:
        </p>
        <pre>
<code># Download file /foo/bar/a.txt to local file ~/src/foo/bar/a.txt.
$ ./titanfiles.py download --host=example.appspot.com --file_path=/foo/bar/a.txt ~/src/foo/bar/

# Download files from /foo/bar/* in to local dir ~/src/foo/bar/.
$ ./titanfiles.py download --host=example.appspot.com --dir_path=/foo/bar ~/src/foo/bar/
</code>
</pre>
        <h3>
          Python client
        </h3>
        <p>
          From any Python program (App Engine or otherwise), you can use <code>RemoteFile</code>
          objects to remotely manage Titan files via the HTTP API.
        </p>
        <p>
          First, you make a <code>RemoteFileFactory</code> (which houses all the configuration and
          auth necessary to make requests), and this use this factory to build
          <code>RemoteFile</code> objects.
        </p>
        <pre>
<code>from titan.files import files_client

host = 'example.appspot.com'
remote_file_factory = files_client.RemoteFileFactory(host=host)

remote_file = remote_file_factory.make_remote_file('/path/to/file.txt')
remote_file.write('foobar')
remote_file.content
remote_file.serialize()
</code>
</pre>
        <p>
          By default, the factory will prompt for an email address and password via stdin. To avoid
          this and pass credentials programmatically, you can pass an <code>auth_function</code>
          argument, which is a callable that returns a two-tuple of <code>(username,
          password)</code>.
        </p>
        <h2>
          See also
        </h2>
        <ul>
          <li>
            <strong><a href="/titan/files/versions.html">Titan Versions</a></strong>: a lightweight
            version control system for atomically updating files.
          </li>
          <li>
            <strong><a href="/titan/files/microversions.html">Titan Microversions</a></strong>:
            automatic versioning of every file change.
          </li>
          <li>
            <strong><a href="/titan/files/mixins.html">Mixins</a></strong>: simple plugins that let
            you extend and customize Titan Files.
          </li>
        </ul>
      </section>
    </div>
    <div class="outer" id="footer_wrap">
      <footer class="inner">
        <p class="copyright">
          © Google - <a href="https://github.com/GoogleCloudPlatform">GoogleCloudPlatform</a>
        </p>
      </footer>
    </div><script src="//www.google.com/js/gweb/analytics/autotrack.js">
</script> <script>
new gweb.analytics.AutoTrack({
      profile: 'UA-24973566-1'
    });
    </script> <script>
(function(){
      var h=this;
function k(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";else if("function"==
b&&"undefined"==typeof a.call)return"object";return b}function n(a){var b=k(a);return"array"==b||"object"==b&&"number"==typeof a.length}function p(a){return"string"==typeof a}function q(a){var b=typeof a;return"object"==b&&null!=a||"function"==b};function r(a){return a.replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")}function s(a){if(!t.test(a))return a;-1!=a.indexOf("&")&&(a=a.replace(v,"&amp;"));-1!=a.indexOf("<")&&(a=a.replace(w,"&lt;"));-1!=a.indexOf(">")&&(a=a.replace(x,"&gt;"));-1!=a.indexOf('"')&&(a=a.replace(aa,"&quot;"));return a}var v=/&/g,w=/</g,x=/>/g,aa=/\"/g,t=/[&<>\"]/;var y=Array.prototype,ba=y.indexOf?function(a,b,c){return y.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(p(a))return!p(b)||1!=b.length?-1:a.indexOf(b,c);for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1},z=y.forEach?function(a,b,c){y.forEach.call(a,b,c)}:function(a,b,c){for(var e=a.length,g=p(a)?a.split(""):a,d=0;d<e;d++)d in g&&b.call(c,g[d],d,a)};function ca(a){var b=a.length;if(0<b){for(var c=Array(b),e=0;e<b;e++)c[e]=a[e];return c}return[]}
function da(a,b,c){return 2>=arguments.length?y.slice.call(a,b):y.slice.call(a,b,c)};var A,B,C,D;function E(){return h.navigator?h.navigator.userAgent:null}D=C=B=A=!1;var F;if(F=E()){var ea=h.navigator;A=0==F.indexOf("Opera");B=!A&&-1!=F.indexOf("MSIE");C=!A&&-1!=F.indexOf("WebKit");D=!A&&!C&&"Gecko"==ea.product}var G=A,H=B,I=D,J=C;function K(){var a=h.document;return a?a.documentMode:void 0}var L;
a:{var M="",N;if(G&&h.opera)var O=h.opera.version,M="function"==typeof O?O():O;else if(I?N=/rv\:([^\);]+)(\)|;)/:H?N=/MSIE\s+([^\);]+)(\)|;)/:J&&(N=/WebKit\/(\S+)/),N)var P=N.exec(E()),M=P?P[1]:"";if(H){var Q=K();if(Q>parseFloat(M)){L=String(Q);break a}}L=M}var R={};
function S(a){var b;if(!(b=R[a])){b=0;for(var c=r(String(L)).split("."),e=r(String(a)).split("."),g=Math.max(c.length,e.length),d=0;0==b&&d<g;d++){var f=c[d]||"",u=e[d]||"",fa=RegExp("(\\d*)(\\D*)","g"),ga=RegExp("(\\d*)(\\D*)","g");do{var l=fa.exec(f)||["","",""],m=ga.exec(u)||["","",""];if(0==l[0].length&&0==m[0].length)break;b=((0==l[1].length?0:parseInt(l[1],10))<(0==m[1].length?0:parseInt(m[1],10))?-1:(0==l[1].length?0:parseInt(l[1],10))>(0==m[1].length?0:parseInt(m[1],10))?1:0)||((0==l[2].length)<
(0==m[2].length)?-1:(0==l[2].length)>(0==m[2].length)?1:0)||(l[2]<m[2]?-1:l[2]>m[2]?1:0)}while(0==b)}b=R[a]=0<=b}return b}var T=h.document,U=!T||!H?void 0:K()||("CSS1Compat"==T.compatMode?parseInt(L,10):5);var ha=!H||H&&9<=U;!I&&!H||H&&H&&9<=U||I&&S("1.9.1");var V=H&&!S("9");function ia(a,b){var c;c=a.className;c=p(c)&&c.match(/\S+/g)||[];for(var e=da(arguments,1),g=c.length+e.length,d=c,f=0;f<e.length;f++)0<=ba(d,e[f])||d.push(e[f]);a.className=c.join(" ");return c.length==g};function ja(a,b){for(var c in a)b.call(void 0,a[c],c,a)}var W="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");function ka(a,b){for(var c,e,g=1;g<arguments.length;g++){e=arguments[g];for(c in e)a[c]=e[c];for(var d=0;d<W.length;d++)c=W[d],Object.prototype.hasOwnProperty.call(e,c)&&(a[c]=e[c])}};function la(a,b){ja(b,function(b,e){"style"==e?a.style.cssText=b:"class"==e?a.className=b:"for"==e?a.htmlFor=b:e in X?a.setAttribute(X[e],b):0==e.lastIndexOf("aria-",0)||0==e.lastIndexOf("data-",0)?a.setAttribute(e,b):a[e]=b})}var X={cellpadding:"cellPadding",cellspacing:"cellSpacing",colspan:"colSpan",frameborder:"frameBorder",height:"height",maxlength:"maxLength",role:"role",rowspan:"rowSpan",type:"type",usemap:"useMap",valign:"vAlign",width:"width"};
function ma(a,b,c){var e=arguments,g=document,d=e[0],f=e[1];if(!ha&&f&&(f.name||f.type)){d=["<",d];f.name&&d.push(' name="',s(f.name),'"');if(f.type){d.push(' type="',s(f.type),'"');var u={};ka(u,f);delete u.type;f=u}d.push(">");d=d.join("")}d=g.createElement(d);f&&(p(f)?d.className=f:"array"==k(f)?ia.apply(null,[d].concat(f)):la(d,f));2<e.length&&na(g,d,e);return d}
function na(a,b,c){function e(c){c&&b.appendChild(p(c)?a.createTextNode(c):c)}for(var g=2;g<c.length;g++){var d=c[g];if(n(d)&&!(q(d)&&0<d.nodeType)){var f;a:{if(d&&"number"==typeof d.length){if(q(d)){f="function"==typeof d.item||"string"==typeof d.item;break a}if("function"==k(d)){f="function"==typeof d.item;break a}}f=!1}z(f?ca(d):d,e)}else e(d)}}var oa={SCRIPT:1,STYLE:1,HEAD:1,IFRAME:1,OBJECT:1},Y={IMG:" ",BR:"\n"};
function Z(a,b,c){if(!(a.nodeName in oa))if(3==a.nodeType)c?b.push(String(a.nodeValue).replace(/(\r\n|\r|\n)/g,"")):b.push(a.nodeValue);else if(a.nodeName in Y)b.push(Y[a.nodeName]);else for(a=a.firstChild;a;)Z(a,b,c),a=a.nextSibling};H&&S("9");!J||S("528");I&&S("1.9b")||H&&S("8")||G&&S("9.5")||J&&S("528");I&&!S("8")||H&&S("9");function $(){}$.a=function(){$.b||($.b=new $)};$.a();var pa=window.document.querySelectorAll(["#main_content h1","#main_content h2","#main_content h3","#main_content h4"]);z(pa,function(a){var b;V&&"innerText"in a?b=a.innerText.replace(/(\r\n|\r|\n)/g,"\n"):(b=[],Z(a,b,!0),b=b.join(""));b=b.replace(/ \xAD /g," ").replace(/\xAD/g,"");b=b.replace(/\u200B/g,"");V||(b=b.replace(/ +/g," "));" "!=b&&(b=b.replace(/^\s*/,""));b=r(b).replace(/\s+/g,"-").replace(/[^a-zA-Z0-9\-\_]/g,"").toLowerCase();a.id=b;b=ma("a",{"class":"anchor",href:"#"+b},"\u00b6");a.appendChild(b)});
      }())
    </script>
  </body>
</html>